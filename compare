#!/bin/bash

set -e

# Color definitions - using proper ANSI escape sequences
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'  # No Color

# Default options
USE_COLOR=true
SHOW_STATS=false
LIMIT_COMMITS=""
REVERSE_ORDER=false
OUTPUT_FILE=""

usage() {
    echo "Usage: compare [OPTIONS] [source_branch] [target_branch]"
    echo ""
    echo "Compare two git branches and show commit differences in a table format."
    echo ""
    echo "OPTIONS:"
    echo "  --no-color       Disable colored output"
    echo "  --help, -h       Show this help message"
    echo "  --stat           Show file change statistics"
    echo "  --limit N        Limit output to N commits per branch"
    echo "  --reverse        Show commits in reverse order (oldest first)"
    echo "  --output FILE    Export results to file"
    echo ""
    echo "Arguments:"
    echo "  source_branch    Source branch to compare from (optional, defaults to current branch)"
    echo "  target_branch    Target branch to compare to (required)"
    echo ""
    echo "Examples:"
    echo "  compare main                          # Compare current branch with main"
    echo "  compare feature/new main              # Compare feature/new with main"
    echo "  compare --stat --limit 5 main         # Show stats, limit to 5 commits"
    echo "  compare --no-color --output diff.txt main  # No colors, save to file"
    echo ""
    exit 1
}

check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Error: This directory is not a git repository${NC}" >&2
        echo -e "${YELLOW}üí° Hint: Run 'git init' to initialize a new repository or navigate to an existing git repository${NC}" >&2
        exit 1
    fi
}

get_current_branch() {
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ "$?" -ne 0 ] || [ "$branch" = "HEAD" ]; then
        echo -e "${RED}‚ùå Error: Unable to determine current branch (possibly in detached HEAD state)${NC}" >&2
        echo -e "${YELLOW}üí° Hint: Checkout a branch with 'git checkout <branch-name>'${NC}" >&2
        exit 1
    fi
    echo "$branch"
}

validate_branch() {
    local branch="$1"
    
    if [ -z "$branch" ]; then
        echo -e "${RED}‚ùå Error: Branch name cannot be empty${NC}" >&2
        exit 1
    fi
    
    # Always prefer origin branches, check remote first
    if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
        return 0
    fi
    
    # Check local branches as fallback
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        return 0
    fi
    
    # Try to find similar branch names
    local similar_branches
    similar_branches=$(git branch -a | grep -i "$branch" | head -3 | sed 's/^[* ] //' | sed 's/remotes\/origin\///')
    
    echo -e "${RED}‚ùå Error: Branch '$branch' does not exist${NC}" >&2
    if [ -n "$similar_branches" ]; then
        echo -e "${YELLOW}ü§î Did you mean one of these?${NC}" >&2
        echo "$similar_branches" | while read -r suggestion; do
            echo -e "  ${CYAN}üåø $suggestion${NC}" >&2
        done
    else
        echo -e "${YELLOW}üí° Hint: Use 'git branch -a' to see available branches${NC}" >&2
    fi
    exit 1
}

print_colored_row() {
    local hash="$1"
    local date="$2"
    local author="$3"
    local subject="$4"
    local stats="$5"
    
    # Truncate fields to fit columns
    author=$(printf "%.20s" "$author")
    subject=$(printf "%.48s" "$subject")
    
    if [ "$USE_COLOR" = true ]; then
        if [ "$SHOW_STATS" = true ] && [ -n "$stats" ]; then
            printf "| ${YELLOW}%-7s${NC} | ${CYAN}%-10s${NC} | ${PURPLE}%-20s${NC} | %-38s | ${BLUE}%8s${NC} |\n" "$hash" "$date" "$author" "$subject" "$stats"
        else
            printf "| ${YELLOW}%-7s${NC} | ${CYAN}%-10s${NC} | ${PURPLE}%-20s${NC} | %-48s |\n" "$hash" "$date" "$author" "$subject"
        fi
    else
        if [ "$SHOW_STATS" = true ] && [ -n "$stats" ]; then
            printf "| %-7s | %-10s | %-20s | %-38s | %8s |\n" "$hash" "$date" "$author" "$subject" "$stats"
        else
            printf "| %-7s | %-10s | %-20s | %-48s |\n" "$hash" "$date" "$author" "$subject"
        fi
    fi
}

count_commits() {
    local commit_range="$1"
    git rev-list --count "$commit_range" 2>/dev/null || echo "0"
}

print_commits_section() {
    local title="$1"
    local commit_range="$2"
    
    local count=$(count_commits "$commit_range")
    local emoji="üìù"
    if [ "$count" -eq 0 ]; then
        emoji="‚úÖ"
    fi
    
    local title_with_count="$emoji $title ($count commits)"
    local title_length=${#title_with_count}
    local separator=$(printf "%*s" $((title_length + 2)) | tr ' ' '=')
    
    if [ "$USE_COLOR" = true ]; then
        printf "${BLUE}%s${NC}\n" "$separator"
        printf "${BLUE} ${GREEN}%s${NC}${BLUE} ${NC}\n" "$title_with_count"
        printf "${BLUE}%s${NC}\n" "$separator"
    else
        printf "%s\n" "$separator"
        printf " %s \n" "$title_with_count"
        printf "%s\n" "$separator"
    fi
    echo ""
    
    if [ "$count" -eq 0 ]; then
        echo "  No commits found."
        return
    fi
    
    # Build git log command
    local git_cmd="git --no-pager log --pretty=format:\"%h|%ad|%an|%s\" --date=short"
    
    if [ "$REVERSE_ORDER" = true ]; then
        git_cmd="$git_cmd --reverse"
    fi
    
    if [ -n "$LIMIT_COMMITS" ]; then
        git_cmd="$git_cmd -n $LIMIT_COMMITS"
    fi
    
    # Get commits and format them
    while IFS='|' read -r hash date author subject; do
        if [[ -n "$hash" ]]; then
            local stats=""
            if [ "$SHOW_STATS" = true ]; then
                stats=$(git show --stat --format="" "$hash" | tail -1 | grep -o '[0-9]\+ files\? changed\|[0-9]\+ insertions\?\|[0-9]\+ deletions\?' | wc -w | tr -d ' ')
                if [ "$stats" -eq 0 ]; then
                    stats=$(git diff-tree --no-commit-id --numstat "$hash" | wc -l | tr -d ' ')
                    stats="${stats}f"
                fi
            fi
            print_colored_row "$hash" "$date" "$author" "$subject" "$stats"
        fi
    done < <(eval "$git_cmd $commit_range")
}

output_to_file() {
    local content="$1"
    local file="$2"
    
    if [ -n "$file" ]; then
        # Strip ANSI colors for file output
        echo "$content" | sed 's/\x1b\[[0-9;]*m//g' > "$file"
        if [ "$USE_COLOR" = true ]; then
            printf "${GREEN}üíæ Output saved to: %s${NC}\n" "$file"
        else
            printf "üíæ Output saved to: %s\n" "$file"
        fi
    else
        echo "$content"
    fi
}

format_commits_table() {
    local source_branch="$1"
    local target_branch="$2"
    
    local output=""
    
    # Capture output
    exec 3>&1
    output=$(
        print_commits_section "Commits in '$source_branch' that are not in '$target_branch':" "$target_branch..$source_branch"
        echo ""
        echo ""
        print_commits_section "Commits in '$target_branch' that are not in '$source_branch':" "$source_branch..$target_branch"
    )
    exec 3>&-
    
    output_to_file "$output" "$OUTPUT_FILE"
}

parse_arguments() {
    local args=()
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                usage
                ;;
            --no-color)
                USE_COLOR=false
                shift
                ;;
            --stat)
                SHOW_STATS=true
                shift
                ;;
            --limit)
                if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    LIMIT_COMMITS="$2"
                    shift 2
                else
                    echo -e "${RED}‚ùå Error: --limit requires a number${NC}" >&2
                    exit 1
                fi
                ;;
            --reverse)
                REVERSE_ORDER=true
                shift
                ;;
            --output)
                if [[ -n "$2" ]]; then
                    OUTPUT_FILE="$2"
                    shift 2
                else
                    echo -e "${RED}‚ùå Error: --output requires a filename${NC}" >&2
                    exit 1
                fi
                ;;
            -*)
                echo -e "${RED}‚ùå Error: Unknown option $1${NC}" >&2
                usage
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    set -- "${args[@]}"
    
    case ${#args[@]} in
        0)
            usage
            ;;
        1)
            SOURCE_BRANCH=$(get_current_branch)
            TARGET_BRANCH="${args[0]}"
            ;;
        2)
            SOURCE_BRANCH="${args[0]}"
            TARGET_BRANCH="${args[1]}"
            ;;
        *)
            echo -e "${RED}‚ùå Error: Too many arguments${NC}" >&2
            usage
            ;;
    esac
}

get_origin_branch() {
    local branch="$1"
    
    # Check if origin branch exists
    if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
        echo "origin/$branch"
    else
        # Fallback to local branch
        echo "$branch"
    fi
}

main() {
    check_git_repo
    
    parse_arguments "$@"
    
    validate_branch "$SOURCE_BRANCH"
    validate_branch "$TARGET_BRANCH"
    
    if [ "$SOURCE_BRANCH" = "$TARGET_BRANCH" ]; then
        echo -e "${RED}‚ùå Error: Source and target branches are the same${NC}" >&2
        exit 1
    fi
    
    # Always use origin branches for comparison
    local source_origin=$(get_origin_branch "$SOURCE_BRANCH")
    local target_origin=$(get_origin_branch "$TARGET_BRANCH")
    
    format_commits_table "$source_origin" "$target_origin"
}

main "$@"